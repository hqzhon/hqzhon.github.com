<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[测试小站]]></title>
  <subtitle><![CDATA[如果方向错了，停下来就是前进。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-10-04T08:52:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[觅不凡]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[java单例模式（Singleton）]]></title>
    <link href="http://yoursite.com/2015/09/30/Singleton/"/>
    <id>http://yoursite.com/2015/09/30/Singleton/</id>
    <published>2015-09-30T08:09:46.000Z</published>
    <updated>2015-10-04T08:52:16.000Z</updated>
    <content type="html"><![CDATA[<p>最近在测试的时候遇到几个关于多线程的问题，其实频繁涉及单例模式相关的问题，因此翻看文章和资料总结了本篇文档，做为后续的学习和工作参考。<br><a id="more"></a></p>
<h2 id="一-_单例模式简介">一. 单例模式简介</h2><h3 id="单例模式是用来创建独一无二的，只有一个实例的对象的模式-使用单例模式创建一个模型，它确保只产生一个实例，并提供一个访问它的全局访问点。">单例模式是用来创建独一无二的，只有一个实例的对象的模式.使用单例模式创建一个模型，它确保只产生一个实例，并提供一个访问它的全局访问点。</h3><h3 id="1-_为什么使用单例模式？">1. 为什么使用单例模式？</h3><p>部分对象使用过程中只能有一个实例，如果制造出多个，会导致很多问题，如程序的行为异常，资源使用过量和数据不一致的情况。</p>
<h3 id="2-_静态变量实现单例的缺点">2. 静态变量实现单例的缺点</h3><p>静态全局变量可以实现单例，但是这样必须在程序一开始就创建好对象，如果对象创建非常耗时，这会导致程序初始化过慢，同时如果执行过程中没有使用过，也会导致资源的浪费。</p>
<h3 id="3-_单例模式应用场景">3. 单例模式应用场景</h3><p>（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。<br>（2）控制资源的情况下，方便资源之间的互相通信。如线程池，缓存等。</p>
<h2 id="二-_六种单例模式实现">二. 六种单例模式实现</h2><h3 id="1-_懒汉">1. 懒汉</h3><p>线程不安全的写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> instance;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>线程安全的写法，但是效率很低<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-_饿汉">2. 饿汉</h3><p>类加载时直接初始化，如果不使用而提前创建会耗用性能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_双重校验锁">3. 双重校验锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。</p>
<p>但是这个方法在单核和多核的cpu下都不能保证很好的工作。问题是由编译器优化导致。编译器优化是指在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。</p>
<p>回到问题，创建对象是非原子操作，会经历如下过程：<br>    1，申请内存，调用构造方法初始化；<br>    2，分配一个指针指向这块区域。<br>这两个操作JVM并没有规定谁先执行，编译器优化过程中就可能导致JVM是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。从而出现以下问题：<br>　　1、线程A进入getHelper()方法；<br>　　2、因为此时helper为空，所以线程A进入synchronized块；<br>　　3、线程A执行 helper = new Helper(); 先将helper指向一块内存，此时helper已经非空，而并未初始化；<br>　　4、同时线程B进入，检查helper不为空，则直接使用这个实例并使用，如果此时helper还为初始化完成就会出现问题。</p>
<p>为解决以上问题，有以下尝试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">            Singleton sc; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">                sc = instance; </span><br><span class="line">                <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">                        <span class="keyword">if</span>(sc == <span class="keyword">null</span>) &#123; </span><br><span class="line">                            sc = <span class="keyword">new</span> Singleton(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                    instance = sc; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来这种方式可以解决问题，但是这种想法完全是错误的！同步块的释放保证在同步块里面的操作必须完成，但是并不保证同步块之后的操作不能因编译器优化而调换到同步块结束之前进行。因此，编译器完全可以把instance=sc;这句移到内部同步块里面执行。这样，程序又是错误的了！</p>
<h3 id="4-_双重校验锁问题解决方案">4. 双重校验锁问题解决方案</h3><p>在JDK 5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。关于volatile关键字分析可参考文章<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">Java并发编程：volatile关键字解析</a>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	Helper hp；</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	hp = helper;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-_内部类实现">5. 内部类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span></span>&#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> InnerSingleton.instance;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟饿汉方式不同的是：饿汉方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为InnerSingleton类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载InnerSingleton类，从而实例化instance。</p>
<p>想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。</p>
<h3 id="6-_枚举实现">6. 枚举实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">do</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</p>
<p>参考文档: <a href="http://cantellow.iteye.com/blog/838473" target="_blank" rel="external">单例模式的七种写法</a> , <a href="http://devbean.blog.51cto.com/448512/203501/" target="_blank" rel="external">深入Java单例模式</a> , <a href="http://book.douban.com/subject/2243615/" target="_blank" rel="external">head first设计模式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在测试的时候遇到几个关于多线程的问题，其实频繁涉及单例模式相关的问题，因此翻看文章和资料总结了本篇文档，做为后续的学习和工作参考。<br>]]>
    
    </summary>
    
      <category term="Singleton" scheme="http://yoursite.com/tags/Singleton/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
