<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[测试小站]]></title>
  <subtitle><![CDATA[如果方向错了，停下来就是前进。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-10-10T09:57:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[觅不凡]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux中/var空间不足的解决办法]]></title>
    <link href="http://yoursite.com/2015/10/10/LowSpace/"/>
    <id>http://yoursite.com/2015/10/10/LowSpace/</id>
    <published>2015-10-10T09:57:39.000Z</published>
    <updated>2015-10-10T09:57:39.000Z</updated>
    <content type="html"><![CDATA[<p>在Linux的使用过程中，如果/var单独分区，但是指定的空间不大，在更新系统或者安装大型软件（如搭建Discourse论坛平台）的时候，使用到了该目录，就可能导致提示空间不足的情况。本文介绍部分解决办法。<br><a id="more"></a></p>
<h3 id="1-_清理自动安装但不再使用的软件">1. 清理自动安装但不再使用的软件</h3><p>使用以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get clean</span><br><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure></p>
<p>autoremove的作用是卸载所有自动安装且不再使用的软件包。<br>autoremove这种方式容易将必要的软件删除掉，尽量不要使用。</p>
<h3 id="2-_使用软链接指向富足的空间区块">2. 使用软链接指向富足的空间区块</h3><p>首先了解下Linux链接的概念。<br>链接是为某一个文件在另外一个位置建立一个不同的链接，分为硬链接和软链接。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux软链接：它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，命令：<span class="built_in">ln</span> －s xxx</span><br><span class="line">Linux硬链接：它会在你选定的位置上生成一个和源文件大小相同的文件，命令：<span class="built_in">ln</span> xxx</span><br></pre></td></tr></table></figure></p>
<p>无论是软链接还是硬链接，文件都保持同步变化。<br>因此，使用软链接可以将/var目录下占用空间较大的目录移动到富足的空间区块（如/home）下，使得/var下不再占用空间。<br>具体实现（www目录为例）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /var/www /home   <span class="comment">#将var下的www目录移动到home或者其他空间富足的区块中</span></span><br><span class="line">ln －s  /home/www /var  <span class="comment">#/var/www指向/home/www，这样www目录将不再占用/var目录的空间</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-_未单独分区情况">3. 未单独分区情况</h3><p>如果/var没有单独分区，则系统默认共享使用/home目录，若此时提示/var空间不足，则说明/home空间不足，这种情况可以清理一下/home目录或者重新安装系统，重新规划分区结构，当然使用软链接方式也是可以的，只要还有其他空间富足的区块。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Linux的使用过程中，如果/var单独分区，但是指定的空间不大，在更新系统或者安装大型软件（如搭建Discourse论坛平台）的时候，使用到了该目录，就可能导致提示空间不足的情况。本文介绍部分解决办法。<br>]]>
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="空间不足" scheme="http://yoursite.com/tags/%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/"/>
    
      <category term="软链接" scheme="http://yoursite.com/tags/%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过反射创建单例模式的另一个实例]]></title>
    <link href="http://yoursite.com/2015/10/05/ReflectionSingleTon/"/>
    <id>http://yoursite.com/2015/10/05/ReflectionSingleTon/</id>
    <published>2015-10-05T04:09:46.000Z</published>
    <updated>2015-10-05T13:07:10.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式是最常见的一个模式，在java中单例模式大量被使用。关于单例模式的实现场景可查看<a href="http://hqzhon.github.io/2015/09/30/Singleton/" target="_blank" rel="external">java单例模式</a>。今天介绍如何利用反射来创建单例模式的另一个实例，以及枚举实现单例模式规避反射的原理。<br><a id="more"></a></p>
<h2 id="一-_反射创建单例模式的另一个实例">一. 反射创建单例模式的另一个实例</h2><h3 id="1-_实现一个单例模式">1. 实现一个单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhonghq.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"single single"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-_使用SingleTon">2. 使用SingleTon</h3><p>我们通过正常方式实例化SingleTon，同时通过反射获取SingleTon的instance，对比它们的地址，如果地址不同就表明另一个实例创建成功。</p>
<p>实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhonghq.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.AccessibleObject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 正常使用单例模式    </span></span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"正常使用singleTon："</span>  + singleTon);</span><br><span class="line">        singleTon.single();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用反射获取instance</span></span><br><span class="line">        Class class1 = Class.forName(<span class="string">"com.zhonghq.reflection.SingleTon"</span>);</span><br><span class="line">        Constructor[]  constructors = class1.getDeclaredConstructors();</span><br><span class="line">        AccessibleObject.setAccessible(constructors, <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors)&#123;</span><br><span class="line">            <span class="keyword">if</span> (c.isAccessible())&#123;</span><br><span class="line">                Object classObject  = c.newInstance();</span><br><span class="line">                System.out.println(<span class="string">"反射使用singleTon："</span> + classObject);</span><br><span class="line">                Method method = class1.getMethod(<span class="string">"single"</span>);</span><br><span class="line">                method.invoke(classObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行，得到以下结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正常使用singleTon：com<span class="class">.zhonghq</span><span class="class">.reflection</span><span class="class">.SingleTon</span>@<span class="number">728</span>edb84</span><br><span class="line">single single</span><br><span class="line">反射使用singleTon：com<span class="class">.zhonghq</span><span class="class">.reflection</span><span class="class">.SingleTon</span>@edf1de</span><br><span class="line">single single</span><br></pre></td></tr></table></figure></p>
<p>可以看到两个地址明显不同，另一个实例创建成功。</p>
<h2 id="二-_枚举方式规避原理">二. 枚举方式规避原理</h2><p>我们同样以代码来查看</p>
<h3 id="1-_实现枚举单例">1. 实现枚举单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhonghq.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleTon &#123;</span><br><span class="line">    instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"enum single"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-_使用SingleTon-1">2. 使用SingleTon</h3><p>修改示例一中使用SingleTon的代码</p>
<pre><code class="java">Class class1 = Class.forName(<span class="string">"com.zhonghq.reflection.SingleTon"</span>);
</code></pre>
<p>修改为：</p>
<pre><code class="java">Class class1 = Class.forName(<span class="string">"com.zhonghq.reflection.EnumSingleTon"</span>);
</code></pre>
<p>其他不变，运行，结果如下：</p>
<pre><code>正常使用singleTon：com<span class="class">.zhonghq</span><span class="class">.reflection</span><span class="class">.SingleTon</span>@<span class="number">728</span>edb84
single single
Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="class">.lang</span><span class="class">.IllegalArgumentException</span>: Cannot reflectively create enum objects
    at java<span class="class">.lang</span><span class="class">.reflect</span><span class="class">.Constructor</span><span class="class">.newInstance</span>(Constructor<span class="class">.java</span>:<span class="number">521</span>)
    at com<span class="class">.zhonghq</span><span class="class">.reflection</span><span class="class">.Main</span><span class="class">.main</span>(Main<span class="class">.java</span>:<span class="number">19</span>)
</code></pre><p>可以看出反射方式执行失败了，抛出了IllegalArgumentException，另一个实例的创建失败。</p>
<p>那么为什么呢？<br>查看异常我们发现问题出在代码Object classObject  = c.newInstance(); 该代码是使用java.lang.reflect.Constructor的newInstance()方法实现的，查看该方法的实现我们发现其禁止了通过反射构造枚举对象，代码如下；</p>
<pre><code class="java"><span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)   
    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);
</code></pre>
]]></content>
    <summary type="html">
    <![CDATA[<p>单例模式是最常见的一个模式，在java中单例模式大量被使用。关于单例模式的实现场景可查看<a href="http://hqzhon.github.io/2015/09/30/Singleton/">java单例模式</a>。今天介绍如何利用反射来创建单例模式的另一个实例，以及枚举实现单例模式规避反射的原理。<br>]]>
    
    </summary>
    
      <category term="Singleton" scheme="http://yoursite.com/tags/Singleton/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java单例模式（Singleton）]]></title>
    <link href="http://yoursite.com/2015/09/30/Singleton/"/>
    <id>http://yoursite.com/2015/09/30/Singleton/</id>
    <published>2015-09-30T08:09:46.000Z</published>
    <updated>2015-10-04T12:32:12.000Z</updated>
    <content type="html"><![CDATA[<p>最近在测试的时候遇到几个关于多线程的问题，其实频繁涉及单例模式相关的问题，因此翻看文章和资料总结了本篇文档，做为后续的学习和工作参考。<br><a id="more"></a></p>
<h2 id="一-_单例模式简介">一. 单例模式简介</h2><h3 id="单例模式是用来创建独一无二的，只有一个实例的对象的模式-使用单例模式创建一个模型，它确保只产生一个实例，并提供一个访问它的全局访问点。">单例模式是用来创建独一无二的，只有一个实例的对象的模式.使用单例模式创建一个模型，它确保只产生一个实例，并提供一个访问它的全局访问点。</h3><h3 id="1-_为什么使用单例模式？">1. 为什么使用单例模式？</h3><p>部分对象使用过程中只能有一个实例，如果制造出多个，会导致很多问题，如程序的行为异常，资源使用过量和数据不一致的情况。</p>
<h3 id="2-_静态变量实现单例的缺点">2. 静态变量实现单例的缺点</h3><p>静态全局变量可以实现单例，但是这样必须在程序一开始就创建好对象，如果对象创建非常耗时，这会导致程序初始化过慢，同时如果执行过程中没有使用过，也会导致资源的浪费。</p>
<h3 id="3-_单例模式应用场景">3. 单例模式应用场景</h3><p>（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。<br>（2）控制资源的情况下，方便资源之间的互相通信。如线程池，缓存等。</p>
<h2 id="二-_六种单例模式实现">二. 六种单例模式实现</h2><h3 id="1-_懒汉">1. 懒汉</h3><p>线程不安全的写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">return</span> instance;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>线程安全的写法，但是效率很低<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-_饿汉">2. 饿汉</h3><p>类加载时直接初始化，如果不使用而提前创建会耗用性能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_双重校验锁">3. 双重校验锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。</p>
<p>但是这个方法在单核和多核的cpu下都不能保证很好的工作。问题是由编译器优化导致。编译器优化是指在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。</p>
<p>回到问题，创建对象是非原子操作，会经历如下过程：<br>    1，申请内存，调用构造方法初始化；<br>    2，分配一个指针指向这块区域。<br>这两个操作JVM并没有规定谁先执行，编译器优化过程中就可能导致JVM是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。从而出现以下问题：<br>　　1、线程A进入getHelper()方法；<br>　　2、因为此时helper为空，所以线程A进入synchronized块；<br>　　3、线程A执行 helper = new Helper(); 先将helper指向一块内存，此时helper已经非空，而并未初始化；<br>　　4、同时线程B进入，检查helper不为空，则直接使用这个实例并使用，如果此时helper还为初始化完成就会出现问题。</p>
<p>为解决以上问题，有以下尝试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">            Singleton sc; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">                sc = instance; </span><br><span class="line">                <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">                        <span class="keyword">if</span>(sc == <span class="keyword">null</span>) &#123; </span><br><span class="line">                            sc = <span class="keyword">new</span> Singleton(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                    instance = sc; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来这种方式可以解决问题，但是这种想法完全是错误的！同步块的释放保证在同步块里面的操作必须完成，但是并不保证同步块之后的操作不能因编译器优化而调换到同步块结束之前进行。因此，编译器完全可以把instance=sc;这句移到内部同步块里面执行。这样，程序又是错误的了！</p>
<h3 id="4-_双重校验锁问题解决方案">4. 双重校验锁问题解决方案</h3><p>在JDK 5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。关于volatile关键字分析可参考文章<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">Java并发编程：volatile关键字解析</a>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Helper helper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	Helper hp；</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	hp = helper;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper == <span class="keyword">null</span>)</span><br><span class="line">                    helper = <span class="keyword">new</span> Helper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-_内部类实现">5. 内部类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span></span>&#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> InnerSingleton.instance;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟饿汉方式不同的是：饿汉方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为InnerSingleton类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载InnerSingleton类，从而实例化instance。</p>
<p>想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。</p>
<h3 id="6-_枚举实现">6. 枚举实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">do</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</p>
<p>参考文档: <a href="http://cantellow.iteye.com/blog/838473" target="_blank" rel="external">单例模式的七种写法</a> , <a href="http://devbean.blog.51cto.com/448512/203501/" target="_blank" rel="external">深入Java单例模式</a> , <a href="http://book.douban.com/subject/2243615/" target="_blank" rel="external">head first设计模式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在测试的时候遇到几个关于多线程的问题，其实频繁涉及单例模式相关的问题，因此翻看文章和资料总结了本篇文档，做为后续的学习和工作参考。<br>]]>
    
    </summary>
    
      <category term="Singleton" scheme="http://yoursite.com/tags/Singleton/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="单例模式" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
